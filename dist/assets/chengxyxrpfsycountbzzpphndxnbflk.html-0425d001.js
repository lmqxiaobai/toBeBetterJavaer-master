import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as a,c as s,a as e,d as n,b as r,e as c}from"./app-1c5b5ce3.js";const l={},p={href:"https://mp.weixin.qq.com/s/e5Q4aJCX9xccTzBBGepx4g",target:"_blank",rel:"noopener noreferrer"},g=e("strong",null,"950 多名",-1),d={href:"https://mp.weixin.qq.com/s/e5Q4aJCX9xccTzBBGepx4g",target:"_blank",rel:"noopener noreferrer"},b=c('<p>在我们平时查询数据库表记录行数的时候，经常会使用到count()函数，比如使用count(*)、count(1)或者count(某个主键或索引列)，今天我们来对比下这些用法中哪个性能最优秀！</p><h2 id="创建短信表" tabindex="-1"><a class="header-anchor" href="#创建短信表" aria-hidden="true">#</a> 创建短信表</h2><p>比如说，你有一张 短信表(sms)，里面放了各种需要发送的短信信息。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-chengxyxrpfsycountbzzpphndxnbflk-98025672-7dbe-4ae6-a158-9d7cbff56396.jpg" alt="sms建表sql" tabindex="0" loading="lazy"><figcaption>sms建表sql</figcaption></figure><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-chengxyxrpfsycountbzzpphndxnbflk-74f3746b-82cf-46bf-9157-38d06ba8d309.jpg" alt="sms表" tabindex="0" loading="lazy"><figcaption>sms表</figcaption></figure><p>需要注意的是<strong>state字段，为0的时候说明这时候短信还未发送。</strong></p><p>此时还会有一个<strong>异步线程</strong>不断的捞起<strong>未发送（state=0）<strong>的短信数据，执行发短信操作，发送成功之后state字段会被</strong>置为1（已发送）</strong>。也就是说<strong>未发送的数据会不断变少</strong>。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-chengxyxrpfsycountbzzpphndxnbflk-24c6b1d6-2d1d-47d1-bd9f-5c19341df46c.jpg" alt="异步线程发送短信" tabindex="0" loading="lazy"><figcaption>异步线程发送短信</figcaption></figure><p>假设由于某些原因，你现在需要做一些监控，比如监控的内容是，<strong>你的sms数据表里还有没有state=0（未发送）的短信，方便判断一下堆积的未发送短信大概在什么样的一个量级。</strong></p><p>为了获取<strong>满足某些条件的行数是多少</strong>，我们一般会使用<strong>count()方法</strong>。</p><p>这时候为了获取未发送的短信数据，我们很自然就想到了使用下面的sql语句进行查询。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>select count(*) from sms where state = 0;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后再把获得数据作为打点发给监控服务。</p><p>当数据表小的时候，这是没问题的，但当数据量大的时候，比如未发送的短信到了<strong>百万量级</strong>的时候，你就会发现，<strong>上面的sql查询时间会变得很长，最后timeout报错，查不出结果了</strong>。</p><p>为什么？</p><p>我们先从<strong>count()方法的原理</strong>聊起。</p><h2 id="count-的原理" tabindex="-1"><a class="header-anchor" href="#count-的原理" aria-hidden="true">#</a> count()的原理</h2><p>count()方法的目的是计算当前sql语句查询得到的<strong>非NULL的行数</strong>。</p><p>我们知道mysql是分为<strong>server层和存储引擎层的</strong>。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-chengxyxrpfsycountbzzpphndxnbflk-dc86c5c9-b340-4f3d-8b73-6a3cc6b607fb.jpg" alt="Mysql架构" tabindex="0" loading="lazy"><figcaption>Mysql架构</figcaption></figure><p>存储引擎层里可以选择各种引擎进行存储，最常见的是innodb、myisam。具体使用哪个存储引擎，可以通过建表sql里的<code>ENGINE</code>字段进行指定。比如这篇文章开头的建表sql里用了<code>ENGINE=InnoDB</code>，那这张表用的就是innodb引擎。</p><p><strong>虽然在server层都叫count()方法，但在不同的存储引擎下，它们的实现方式是有区别的。</strong></p><p>比如同样是<strong>读全表数据</strong> <code>select count(*) from sms；</code>语句。</p><p>使用 <strong>myisam引擎</strong>的数据表里有个记录当前表里有几行数据的字段，直接读这个字段返回就好了，因此速度快得飞起。</p><p>而使用<strong>innodb引擎</strong>的数据表，则会选择<strong>体积最小的索引树</strong>，然后通过遍历叶子节点的个数挨个加起来，这样也能得到全表数据。</p><p>因此回到文章开头的问题里，当数据表行数变大后，<strong>单次count就需要扫描大量的数据</strong>，因此很可能就会出现超时报错。</p><p>那么问题就来了。</p><p><strong>为什么innodb不能像myisam那样实现count()方法</strong></p><p>myisam和innodb这两个引擎，有几个比较明显的区别，这个是八股文常考了。</p><p>其中<strong>最大的区别在于myisam不支持事务，而innodb支持事务。</strong></p><p>而事务，有四层隔离级别，其中<strong>默认隔离级别就是可重复读隔离级别（RR）</strong>。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-chengxyxrpfsycountbzzpphndxnbflk-da350ad3-d398-4e39-bf9b-77c5c2162e5e.jpg" alt="四层隔离级别" tabindex="0" loading="lazy"><figcaption>四层隔离级别</figcaption></figure><p>innodb引擎通过MVCC实现了<strong>可重复隔离级别</strong>，事务开启后，多次执行同样的<strong>select快照读</strong>，要能读到同样的数据。</p><p>于是我们看个例子。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-chengxyxrpfsycountbzzpphndxnbflk-19cf87d5-c1bd-4f83-9d37-74ae6eb82543.jpg" alt="为什么innodb不单独记录表行数" tabindex="0" loading="lazy"><figcaption>为什么innodb不单独记录表行数</figcaption></figure><p>对于两个事务A和B，一开始sms表假设就<strong>2条</strong>数据，那事务A一开始确实是读到2条数据。事务B在这期间插入了1条数据，按道理数据库其实有3条数据了，但由于可重复读的隔离级别，事务A依然还是只能读到2条数据。</p><p>因此由于事务隔离级别的存在，<strong>不同的事务在同一时间下，看到的表内数据行数是不一致的</strong>，因此innodb，没办法，也没必要像myisam那样单纯的加个count字段信息在数据表上。</p><p>那如果不可避免要使用count()，有没有办法让它快一点？</p><h2 id="各种count-方法的原理" tabindex="-1"><a class="header-anchor" href="#各种count-方法的原理" aria-hidden="true">#</a> 各种count()方法的原理</h2><p>count()的括号里，可以放各种奇奇怪怪的东西，想必大家应该看过，比如放个星号*，放个1，放个索引列啥的。</p><p>我们来分析下他们的执行流程。</p><p><strong>count方法的大原则是server层会从innodb存储引擎里读来一行行数据，并且只累计非null的值</strong>。但这个过程，根据count()方法括号内的传参，有略有不同。</p><h3 id="count" tabindex="-1"><a class="header-anchor" href="#count" aria-hidden="true">#</a> count(*)</h3><p>server层拿到innodb返回的行数据，<strong>不对里面的行数据做任何解析和判断</strong>，默认取出的值肯定都不是null，直接行数+1。</p><h3 id="count-1" tabindex="-1"><a class="header-anchor" href="#count-1" aria-hidden="true">#</a> count(1)</h3><p>server层拿到innodb返回的行数据，每行放个1进去，默认不可能为null，直接行数+1.</p><h3 id="count-某个列字段" tabindex="-1"><a class="header-anchor" href="#count-某个列字段" aria-hidden="true">#</a> count(某个列字段)</h3><p>由于指明了要count某个字段，innodb在取数据的时候，会把这个字段<strong>解析出来</strong>返回给server层，所以会<strong>比count(1)和count(*)多了个解析字段出来的流程。</strong></p><ul><li>如果这个列字段是<strong>主键id</strong>，主键是不可能为null的，所以server层也不用判断是否为null，innodb每返回一行，行数结果就+1.</li><li>如果这个列是<strong>普通索引字段</strong>，innodb一般会<strong>走普通索引</strong>，每返回一行数据，server层就会判断这个字段是否为null，不是null的情况下+1。当然如果建表sql里字段定义为not null的话，那就不用做这一步判断直接+1。</li><li>如果这个列<strong>没有加过索引</strong>，那innodb可能会全表扫描，返回的每一行数据，server层都会判断这个字段是否为null，不是null的情况下+1。同上面的情况一样，字段加了not null也就省下这一步判断了。</li></ul><p>理解了原理后我们大概可以知道他们的性能排序是</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>count(*) ≈ count(1) &gt; count(主键id) &gt; count(普通索引列) &gt; count(未加索引列)\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>所以说count(*)，已经是最快的了。</strong></p><p>知道真相的我眼泪掉下来。</p><p>那有没有其他更好的办法？</p><h2 id="允许粗略估计行数的场景" tabindex="-1"><a class="header-anchor" href="#允许粗略估计行数的场景" aria-hidden="true">#</a> 允许粗略估计行数的场景</h2><p>我们回过头来细品下文章开头的需求，我们只是希望知道数据库里还有多少短信是堆积在那没发的，具体是1k还是2k其实都是差不多量级，等到了百万以上，具体数值已经不重要了，我们知道它现在堆积得很离谱，就够了。因此这个场景，其实是允许使用<strong>比较粗略</strong>的估计的。</p><p><strong>那怎么样才能获得粗略的数值呢？</strong></p><p>还记得我们平时为了查看sql执行计划用的<strong>explain命令</strong>不。</p><p>其中有个<strong>rows</strong>，会用来<strong>估计</strong>接下来执行这条sql需要扫描和检查多少行。它是通过采样的方式计算出来的，虽然会有一定的偏差，但它能反映一定的数量级。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-chengxyxrpfsycountbzzpphndxnbflk-f5749485-f71b-4b39-8e8f-5b8af18d52d4.jpg" alt="explain里的rows" tabindex="0" loading="lazy"><figcaption>explain里的rows</figcaption></figure><p>有些语言的orm里可能没有专门的explain语法，但是肯定有执行raw sql的功能，你<strong>可以把explain语句当做raw sql传入，从返回的结果里将rows那一列读出来使用。</strong></p><p>一般情况下，explain的sql如果能走索引，那会比不走索引的情况更准 。单个字段的索引会比多个字段组成的复合索引要准。索引区分度越高，rows的值也会越准。</p><p>这种情况几乎满足大部分的监控场景。但总有一些场景，它要求必须得到精确的行数，这种情况该怎么办呢？</p><h2 id="必须精确估计行数的场景" tabindex="-1"><a class="header-anchor" href="#必须精确估计行数的场景" aria-hidden="true">#</a> 必须精确估计行数的场景</h2><p>这种场景就比较头疼了，但也不是不能做。</p><p>我们可以单独拉一张新的数据库表，只为保存各种场景下的count。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE `count_table` (\n  `id` int NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  `cnt_what` char(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;各种需要计算的指标&#39;,\n  `cnt` tinyint NOT NULL COMMENT &#39;cnt指标值&#39;,\n  PRIMARY KEY (`id`),\n  KEY `idx_cnt_what` (`cnt_what`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-chengxyxrpfsycountbzzpphndxnbflk-625c4cd5-b4f8-4781-833c-70c3fe663c80.jpg" alt="counttable表保存各种场景下的count" tabindex="0" loading="lazy"><figcaption>count_table表保存各种场景下的count</figcaption></figure><p>当需要获取某个场景下的cout值时，可以使用下面的sql进行直接读取，<strong>快得飞起</strong>。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>select cnt from count_table where cnt_what = &quot;未发送的短信数量&quot;; \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>那这些count的结果值从哪来呢？</strong></p><p>这里分成两种情况。</p><h3 id="实时性要求较高的场景" tabindex="-1"><a class="header-anchor" href="#实时性要求较高的场景" aria-hidden="true">#</a> 实时性要求较高的场景</h3><p>如果你对这个cnt计算结果的实时性要求很高，那你需要<strong>将更新cnt的sql加入到对应变更行数的事务中</strong>。</p><p>比如我们有两个事务A和B，分别是增加未发送短信和减少未发送短信。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-chengxyxrpfsycountbzzpphndxnbflk-b456cbbc-695c-4480-91d2-9b613ee488b4.jpg" alt="将更改表行数的操作放入到事务里" tabindex="0" loading="lazy"><figcaption>将更改表行数的操作放入到事务里</figcaption></figure><p>这样做的<strong>好处</strong>是事务内的cnt行数依然符合隔离级别，事务回滚的时候，cnt的值也会跟着回滚。</p><p><strong>坏处</strong>也比较明显，多个线程对同一个cnt进行写操作，会触发悲观锁，多个线程之间需要互相等待。对于<strong>高频写的场景</strong>，性能会有折损。</p><h3 id="实时性没那么高的场景" tabindex="-1"><a class="header-anchor" href="#实时性没那么高的场景" aria-hidden="true">#</a> 实时性没那么高的场景</h3><p>如果实时性要求不高的话，比如可以一天一次，那你可以通过全表扫描后做计算。</p><p>举个例子，比如上面的短信表，可以<strong>按id排序</strong>，每次取出1w条数据，<strong>记下这一批里最大的id，然后下次从最大id开始再拿1w条数据出来，不断循环。</strong></p><p>对于未发送的短信，就只需要在捞出的那1w条数据里，筛选出state=0的条数。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-chengxyxrpfsycountbzzpphndxnbflk-ade1d243-6e1e-401a-b132-c5b0e810ea15.jpg" alt="batch分批获取短信表" tabindex="0" loading="lazy"><figcaption>batch分批获取短信表</figcaption></figure><p>当然如果有条件，这种场景最好的方式还是<strong>消费binlog将数据导入到hive里</strong>，然后在hive里做查询，不少公司也已经有现成的组件可以做这种事情，不用自己写脚本，岂不美哉。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-chengxyxrpfsycountbzzpphndxnbflk-bd3e2b9b-0b80-47aa-b359-77d85f36930f.jpg" alt="mysql同步hive" tabindex="0" loading="lazy"><figcaption>mysql同步hive</figcaption></figure><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>mysql用count方法<strong>查全表数据</strong>，在不同的存储引擎里实现不同，myisam有专门字段记录全表的行数，直接读这个字段就好了。而innodb则需要一行行去算。</li><li>性能方面 <code>count(*) ≈ count(1) &gt; count(主键id) &gt; count(普通索引列) &gt; count(未加索引列)</code>，但哪怕是性能最好的count(*)，由于实现上就需要一行行去算，所以数据量大的时候就是不给力。</li><li>如果确实需要获取行数，且**可以接受不那么精确的行数（只需要判断大概的量级）**的话，那可以用explain里的rows，这可以满足大部分的监控场景，实现简单。</li><li><strong>如果要求行数准确</strong>，可以建个新表，里面专门放表行数的信息。</li><li>如果对<strong>实时性要求比较高</strong>的话，可以将更新行数的sql放入到对应事务里，这样既能满足事务隔离性，还能快速读取到行数信息。</li><li>如果对<strong>实时性要求不高</strong>，接受一小时或者一天的更新频率，那既可以自己写脚本遍历全表后更新行数信息。也可以将通过监听binlog将数据导入hive，需要数据时直接通过hive计算得出。</li></ul><hr><p>没有什么使我停留——除了目的，纵然岸旁有玫瑰、有绿荫、有宁静的港湾，我是不系之舟。</p>',89),u={href:"https://mp.weixin.qq.com/s/gOuoM27tl4l6GW7aqZu98Q",target:"_blank",rel:"noopener noreferrer"},h={href:"https://mp.weixin.qq.com/s/3Iry19JaEoN4pA3-JDtVhw",target:"_blank",rel:"noopener noreferrer"},f={href:"https://mp.weixin.qq.com/s/CyJAVQza-9zmDdboStKe8w",target:"_blank",rel:"noopener noreferrer"},m={href:"https://mp.weixin.qq.com/s/4qHRBcJn1AvP07U4H6JcOQ",target:"_blank",rel:"noopener noreferrer"},x={href:"https://mp.weixin.qq.com/s/MGqyie9KvD6kH8Tuv2mqOw",target:"_blank",rel:"noopener noreferrer"},v={href:"https://mp.weixin.qq.com/s/Pu1cddsQOiMfCU4I96iygQ",target:"_blank",rel:"noopener noreferrer"},_={href:"https://mp.weixin.qq.com/s/9f_sOLiRwDS3pzC-mJ9jLQ",target:"_blank",rel:"noopener noreferrer"},q={href:"https://mp.weixin.qq.com/s/zYLEUmbfmiKeFk03e1TxbA",target:"_blank",rel:"noopener noreferrer"},y={href:"https://mp.weixin.qq.com/s/QYFB2NHhyZSBfdgSUcZU5g",target:"_blank",rel:"noopener noreferrer"},w={href:"https://mp.weixin.qq.com/s/SfEUk-4hE6ezUk2Lu6cd2g",target:"_blank",rel:"noopener noreferrer"},z=e("figure",null,[e("img",{src:"https://files.mdnice.com/user/3903/b7e50cf4-6fca-4511-9bfd-aa1ed9eb587b.png",alt:"",tabindex:"0",loading:"lazy"}),e("figcaption")],-1),k={href:"https://mp.weixin.qq.com/s/eh7G_J3a0JudZRR-wrElag",target:"_blank",rel:"noopener noreferrer"};function j(E,N){const t=i("ExternalLinkIcon");return a(),s("div",null,[e("blockquote",null,[e("p",null,[n("一个人可以走得很快，但一群人才能走得更远。当你处在一个学习氛围浓烈的环境中时，就会不由自主地往前冲刺。"),e("a",p,[n("二哥的编程星球"),r(t)]),n("已经有 "),g,n(" 球友加入了，如果你也需要一个良好的学习氛围，"),e("a",d,[n("戳链接"),r(t)]),n("加入我们吧。")])]),b,e("ul",null,[e("li",null,[e("a",u,[n("曝光秋招毁约公司"),r(t)])]),e("li",null,[e("a",h,[n("垃圾外包，离职也罢"),r(t)])]),e("li",null,[e("a",f,[n("非科班转码"),r(t)])]),e("li",null,[e("a",m,[n("推荐 10 个神级 Intellij IDEA 插件"),r(t)])]),e("li",null,[e("a",x,[n("美团率先开奖 24k，不甘心？"),r(t)])]),e("li",null,[e("a",v,[n("Fleet，Java 轻量级 IDE 的未来？"),r(t)])]),e("li",null,[e("a",_,[n("先不管那么多，offer 接了再说"),r(t)])]),e("li",null,[e("a",q,[n("一套 KTV 管理系统，估价 3 万还是 30 万？"),r(t)])]),e("li",null,[e("a",y,[n("给 offer 的公司不问技术细节？"),r(t)])]),e("li",null,[e("a",w,[n("入职一个月，就想跑路了？"),r(t)])])]),z,e("blockquote",null,[e("p",null,[n("参考链接："),e("a",k,[n("https://mp.weixin.qq.com/s/eh7G_J3a0JudZRR-wrElag"),r(t)]),n("，出处：macrozheng，整理：沉默王二")])])])}const A=o(l,[["render",j],["__file","chengxyxrpfsycountbzzpphndxnbflk.html.vue"]]);export{A as default};
