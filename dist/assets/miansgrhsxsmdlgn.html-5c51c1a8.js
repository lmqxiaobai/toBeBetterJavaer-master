import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as n,c as r,a as e,d as a,b as o,e as d}from"./app-1c5b5ce3.js";const l={},p=d('<p>真实面试小场景：</p><p>经过八股和算法的交锋，小二松了口气，都hold住了。只见面试官老王微微一笑，“其实，我真正想问的是……你觉得扫码登录应该怎么实现。”</p><p>小二：“啊……这个，哦……那个，这个就这么，然后……额……嗯……”</p><p>面试官老王：“了解了，回去等通知吧。”</p><p>完……</p><hr><p>好了，铺垫结束，进入我们今天的主题，<strong>扫码登录功能该如何实现</strong>？</p><h2 id="扫码登录场景" tabindex="-1"><a class="header-anchor" href="#扫码登录场景" aria-hidden="true">#</a> 扫码登录场景</h2><p>扫码登录场景想必我们都不陌生——很多PC端的网站都提供了扫码登录的功能，无需在网页上输入任何账号和密码，只需要通过手机上的APP，如微信、淘宝、QQ等等，使用扫描功能，扫描网页上的二维码，确认登录，就可以完成网页端登录。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-86315129-1521-4f67-b097-9d3f8ecace2f.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="扫码登录分析" tabindex="-1"><a class="header-anchor" href="#扫码登录分析" aria-hidden="true">#</a> 扫码登录分析</h2><p>我们来分析一下，扫码登录，其实涉及到<code>三种角色</code>，需要解决<code>两个问题</code>。</p><h3 id="三种角色" tabindex="-1"><a class="header-anchor" href="#三种角色" aria-hidden="true">#</a> 三种角色</h3><p>很明显，扫码登录当中涉及到的三种角色：<code>PC端</code>、<code>手机端</code>、<code>服务端</code>。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-fe5c2e6f-3afd-4614-b52a-3b4ff6800f02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>相关的设计都要围绕这<code>三端</code>来展开，具体的设计其实就是每一端应该完成什么功能？应该怎么实现？端和端应该如何交互？</p><h3 id="两个问题" tabindex="-1"><a class="header-anchor" href="#两个问题" aria-hidden="true">#</a> 两个问题</h3><p>扫码登录本质上是一种特殊的登录认证方式，我们面对的是两个问题</p><ul><li><code>手机端</code>如何完成认证</li><li><code>PC端</code>如何完成登录</li></ul><p>如果用普通的账号密码方式登录认证，PC端通过账号密码完成认证，然后服务端给PC端同步返回token key之类的标识，PC端再次请求服务端，需要携带token key，用于标识和证明自己登录的状态。</p><p>服务端响应的时候，需要对token key进行校验，通过则正常响应；校验不通过，认证失败；或者token过期，PC端需要再次登录认证，获取新的token key。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-67e71850-ab1c-4265-ba3d-d535d0854c93.jpg" alt="账号/密码登录过程" tabindex="0" loading="lazy"><figcaption>账号/密码登录过程</figcaption></figure><p>现在换成了扫码登录：</p><ul><li>认证不是通过账号密码了，而是由手机端扫码来完成</li><li>PC端没法同步获取认证成功之后的凭据，必须用某种方式来让PC端获取认证的凭据。</li></ul><h2 id="扫码登录实现" tabindex="-1"><a class="header-anchor" href="#扫码登录实现" aria-hidden="true">#</a> 扫码登录实现</h2><h3 id="手机端如何完成认证" tabindex="-1"><a class="header-anchor" href="#手机端如何完成认证" aria-hidden="true">#</a> 手机端如何完成认证</h3><h4 id="二维码怎么生成" tabindex="-1"><a class="header-anchor" href="#二维码怎么生成" aria-hidden="true">#</a> 二维码怎么生成</h4><p>二维码和超市里的条形码类似，超市的条形码实际是一串数字，上面存储了商品的序列号。</p><p>二维码的内容就比较自由，里面不止可以存数字，还可以存任何的字符串。我们可以认为，它就是字符的另外一种表现形式。</p><p>下面我通过一个网站把文字转成了二维码：</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-3fd81eb5-5c0e-454a-a96a-b6f78612ed9c.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>所以，我们手机扫码这个过程，其实是对二维码的解码，获取二维码中包含的数据。</p><p><strong>那么二维码怎么生成呢？</strong></p><p>首先，二维码是展示在我们的PC端，所以生成这个操作应该由PC端去请求服务端，获取相应的数据，再由PC端生成这个二维码。</p><p><strong>二维码包含什么呢？</strong></p><p>二维码在我们这个场景里面是一个重要的媒介，服务端必须给这个数据生成惟一的标识作为二维码ID，同时还应该设置过期的时间。PC端根据二维码ID等数据生成二维码。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-38073c93-678a-4f19-9db2-cf89acb4295e.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>同时，服务端也应该保存二维码的一些状态：<code>未扫描</code>、<code>已成功</code>、<code>已失效</code>。</p><h4 id="app认证机制" tabindex="-1"><a class="header-anchor" href="#app认证机制" aria-hidden="true">#</a> APP认证机制</h4><p>我们还得认识一下基于APP的移动互联网认证机制。</p><p>首先，手机端一般是不会存储登录密码的，我们我们发现，只有装载APP，第一次登录的时候，才需要进行基于账号密码的登录，之后即使这个清理掉这个应用进程，甚至手机重启，都是不需要再次输入账号密码的，它可以自动登录。</p><p>这背后有一套基于token的认证机制，和PC有些类似，但又有一些不同。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-aabd9efb-073a-40ca-bf89-9f04add94dbc.jpg" alt="APP端登录认证" tabindex="0" loading="lazy"><figcaption>APP端登录认证</figcaption></figure><ul><li>APP登录认证的时候除了账号密码，还有设备信息</li><li>账号密码校验通过，服务端会把账号与设备进行一个绑定，进行持久化的保存，包含了账号ID，设备ID，设备类型等等</li><li>APP每次请求除了携带token key，还需要携带设备信息。</li></ul><p>因为移动端的设备具备唯一性，可以为每个客户端生成专属token，这个token也不用过期，所以这就是我们可以一次登录，长久使用的原理。</p><h4 id="手机扫码干了什么" tabindex="-1"><a class="header-anchor" href="#手机扫码干了什么" aria-hidden="true">#</a> 手机扫码干了什么</h4><p>那这下就清楚了，我们手机扫码干了两件事：</p><ul><li><code>扫描二维码</code>：识别PC端展示的二维码，获取二维码ID</li></ul><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-2b1e6388-651c-455a-8b53-48d21d01f328.jpg" alt="扫描" tabindex="0" loading="lazy"><figcaption>扫描</figcaption></figure><ul><li><code>确认登录</code>：手机端通过带认证信息(token key、设备信息)、二维码信息（二维码ID）请求服务端，完成认证过程，确认PC端的登录。</li></ul><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-64710a20-1dab-4070-b276-62b237b53d29.jpg" alt="确认登录" tabindex="0" loading="lazy"><figcaption>确认登录</figcaption></figure><blockquote><p>ps: 关于手机扫码和确认，不是重点，所以这里进行了简化，一种说法是扫码时同时向服务端申请一次性临时token，确认登录的时候携带这个临时token来访问服务端。</p></blockquote><h3 id="pc端如何完成登录" tabindex="-1"><a class="header-anchor" href="#pc端如何完成登录" aria-hidden="true">#</a> PC端如何完成登录</h3><p>接下来到我们的重头戏了，手机端完成了它的工作，我们服务端的登录怎么进入登录状态呢？</p><p>我们前面讲了，PC端通过token来标识登录状态。那么手机端扫码确认之后，我们的服务端就应该给PC生成相应的token。</p><p>那么，这个PC端又如何获取它所需的token key，来完成登录呢？</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-ec79824f-70fe-41f2-a68d-69253f6d3f02.jpg" alt="如何获取PC token" tabindex="0" loading="lazy"><figcaption>如何获取PC token</figcaption></figure><p>PC端可以通过获取二维码的状态来进行相应的响应：</p><ul><li>二维码<code>未扫描</code>：无操作</li><li>二维码<code>已失效</code>：提示刷新二维码</li><li>二维码<code>已成功</code>：从服务端获取PC token</li></ul><p>获取二维码状态，主要有三种方式：</p><h4 id="轮询" tabindex="-1"><a class="header-anchor" href="#轮询" aria-hidden="true">#</a> 轮询</h4><p>轮询方式是指客户端会每隔一段时间就主动给服务端发送一次二维码状态的查询请求。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-577a805c-f8f0-435c-bce2-1ddd7fc37a17.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="长轮询" tabindex="-1"><a class="header-anchor" href="#长轮询" aria-hidden="true">#</a> 长轮询</h4><p>长轮询是指客户端主动给服务端发送二维码状态的查询请求，服务端会按情况对请求进行阻塞，直至二维码信息更新或超时。当客户端接收到返回结果后，若二维码仍未被扫描，则会继续发送查询请求，直至状态变化（已失效或已成功）。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-7b93c013-3f28-4ef1-81e0-a7260257d7e5.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="websocket" tabindex="-1"><a class="header-anchor" href="#websocket" aria-hidden="true">#</a> Websocket</h4><p>Websocket是指前端在生成二维码后，会与后端建立连接，一旦后端发现二维码状态变化，可直接通过建立的连接主动推送信息给前端。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-0aec0448-7820-4082-a2a4-7ea0524a3154.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>通过前面的分析，我们已经知道了二维码扫码登录的一些关键点，现在我们把这些点串起来，来看一看二维码扫码登录的整体的实现流程。</p><p>以常用的轮询方式获取二维码状态为例：</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-miansgrhsxsmdlgn-c14345f7-c073-46a0-9d53-0408c01a742f.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>访问PC端二维码生成页面，PC端请求服务端获取<code>二维码ID</code></li><li>服务端生成相应的<code>二维码ID</code>，设置二维码的过期时间，状态等。</li><li>PC获取<code>二维码ID</code>，生成相应的二维码。</li><li>手机端扫描二维码，获取<code>二维码ID</code>。</li><li>手机端将<code>手机端token</code>和<code>二维码ID</code>发送给服务端，确认登录。</li><li>服务端校验<code>手机端token</code>，根据<code>手机端token</code>和<code>二维码ID</code>生成<code>PC端token</code></li><li>PC端通过轮询方式请求服务端，通过<code>二维码ID</code>获取二维码状态，如果已成功，返回<code>PC token</code>，登录成功。</li></ol><p>好了，这样我们一个扫描登录的功能就设计完成了。</p>',75),s={href:"https://mp.weixin.qq.com/s/nVWIPEzlpRdZjLTEFDdMxA",target:"_blank",rel:"noopener noreferrer"};function g(h,b){const i=c("ExternalLinkIcon");return n(),r("div",null,[p,e("blockquote",null,[e("p",null,[a("参考链接："),e("a",s,[a("https://mp.weixin.qq.com/s/nVWIPEzlpRdZjLTEFDdMxA"),o(i)]),a("，出处：三分恶，整理：沉默王二")])])])}const x=t(l,[["render",g],["__file","miansgrhsxsmdlgn.html.vue"]]);export{x as default};
